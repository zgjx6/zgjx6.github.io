<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  
    

    
  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="转载," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Swift的简单教程，原文:https://github.com/900116/Technology-Simple-Tutorial">
<meta name="keywords" content="转载">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift简单教程">
<meta property="og:url" content="http://yoursite.com/2017/05/22/Swift简单教程/index.html">
<meta property="og:site_name" content="zgjx的博客">
<meta property="og:description" content="Swift的简单教程，原文:https://github.com/900116/Technology-Simple-Tutorial">
<meta property="og:updated_time" content="2017-06-15T09:25:50.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift简单教程">
<meta name="twitter:description" content="Swift的简单教程，原文:https://github.com/900116/Technology-Simple-Tutorial">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":true,"scrollpercent":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/05/22/Swift简单教程/"/>





  <title>Swift简单教程 | zgjx的博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zgjx的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">....-/.----/-..../...--/--.../...--/--.../....-/---../.----/----./....-/----./..---/----./...--/----./.----</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/22/Swift简单教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zgjx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zgjx的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Swift简单教程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T14:36:38+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/转载/" itemprop="url" rel="index">
                    <span itemprop="name">转载</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  Swift的简单教程，原文:https://github.com/900116/Technology-Simple-Tutorial
              </div>
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="整数的进制"><a href="#整数的进制" class="headerlink" title="整数的进制"></a>整数的进制</h3><p>十进制：<figure class="highlight plain"><figcaption><span>d = 17```<br>  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">二进制：```let b = 0b00100```&lt;br&gt;  </div><div class="line">八进制：```let o = 0o21```&lt;br&gt;  </div><div class="line">十六进制: ```let h = 0x1a43```  </div><div class="line"></div><div class="line">### typealias  </div><div class="line"></div><div class="line">```typealias UID = UInt16```  </div><div class="line"></div><div class="line">### 布尔  </div><div class="line"></div><div class="line">```let x = true```  </div><div class="line"></div><div class="line">### if  </div><div class="line"></div><div class="line">以下代码不会编译通过&lt;br&gt;  </div><div class="line"></div><div class="line">```  </div><div class="line">let x = 1</div><div class="line">if x &#123;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">正确写法  </div><div class="line"></div><div class="line">```  </div><div class="line">let x = 1</div><div class="line">if x == 1 &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断是否有值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if let a = b &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">if let c = d, e = f &#123;</div><div class="line">//必须,d和f都有值,该语句才能为真</div><div class="line">//否则需要嵌套处理</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="和"><a href="#和" class="headerlink" title="?和!"></a>?和!</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let possibleString: String? = &quot;An optional string.&quot;</div><div class="line">let forcedString: String = possibleString! // 需要感叹号来获取值</div><div class="line">let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;</div><div class="line">let implicitString: String = assumedString  // 不需要感叹号</div><div class="line"></div><div class="line"></div><div class="line">只有被?类型的变量值才能为nil</div><div class="line">?类型的变量需要解包才能进行调用</div><div class="line">!类型的变量不需要解包</div><div class="line">用!进行解包如果变量没有值则会崩溃，用?则不会</div><div class="line">例如：a!.func1() b?.func2()</div><div class="line">!可以放在变量后面进行解包赋值，?必须放在调用前面</div></pre></td></tr></table></figure>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let httpError = (404,&quot;Not Found&quot;)</div></pre></td></tr></table></figure>
<p>关于解包,与python不同,不支持下标访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let (status,msg) = httpError</div><div class="line">let httpError2 = (statusCode:200,description:&quot;OK&quot;)</div><div class="line">let statusCode = httpError2.statusCode</div><div class="line">let description = httpError2.description</div></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>函数抛出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func canThrowAnError() throws &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>块内抛出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">	try canThrowAnError()</div><div class="line">&#125; catch &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多种异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func makeASandwich() throws &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">&#125; catch SandwichError.outOfCleanDishes &#123;</div><div class="line"></div><div class="line">&#125; catch SandwichError.missingIngredients(let ingredients) &#123;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">assert(age &gt;= 0)</div><div class="line">assert(age &gt;= 0,&quot;A person&apos;s age cannot be less than zero&quot;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意：</div><div class="line">当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置</div><div class="line">选项来 build 时，断言会被禁用。</div></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="gt-和-lt"><a href="#gt-和-lt" class="headerlink" title="&gt;= 和 &lt;="></a>&gt;= 和 &lt;=</h3><p>swift可以使用&gt;=或者&lt;=进行判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 &gt;= 1   // true, 因为 1 大于等于 1</div><div class="line">2 &lt;= 1   // false, 因为 2 并不小于等于 1</div></pre></td></tr></table></figure>
<h3 id="元组的比较"><a href="#元组的比较" class="headerlink" title="元组的比较"></a>元组的比较</h3><p>元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;)   // true，因为 1 小于 2</div><div class="line">(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;)    // true，因为 3 等于 3，但是 apple 小于 bird</div><div class="line">(4, &quot;dog&quot;) == (4, &quot;dog&quot;)      // true，因为 4 等于 4，dog 等于 dog</div></pre></td></tr></table></figure>
<h3 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h3><p><code>a ?? b</code><br><br>可以表示<br><br><code>a != nil ? a! : b</code><br><br>如果a不等于空取a(强制解包)的值,否则取b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let defaultColorName = &quot;red&quot;</div><div class="line">var userDefinedColorName: String?   //默认值为 nil</div><div class="line"></div><div class="line">var colorNameToUse = userDefinedColorName ?? defaultColorName</div><div class="line">// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 &quot;red&quot;</div></pre></td></tr></table></figure>
<h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><p><code>a...b</code>表示定义一个闭区间(包括a和b的值):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for i in 1...5 :</div><div class="line">	print(i)  //打印1，2，3，4，5</div></pre></td></tr></table></figure>
<p><code>a..&lt;b</code>表示定义一个半开区间(包括a的值，不包括b的值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for i in 1..&lt;5 :</div><div class="line">	print(i)  //打印1，2，3，4</div></pre></td></tr></table></figure>
<h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let someStr = &quot;abcdef&quot;</div></pre></td></tr></table></figure>
<h3 id="字符串支持-和-操作"><a href="#字符串支持-和-操作" class="headerlink" title="字符串支持+和+=操作"></a>字符串支持+和+=操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myStr = &quot;a&quot;</div><div class="line">myStr += &quot;b&quot;</div><div class="line">let a_str = &quot;a&quot;</div><div class="line">let b_str = &quot;b&quot;</div><div class="line">let c_str = a_str+b_str</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意：</div><div class="line">您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</div></pre></td></tr></table></figure>
<h3 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h3><p>任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。</p>
<h3 id="使用字符"><a href="#使用字符" class="headerlink" title="使用字符"></a>使用字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let c_a:Character = &quot;a&quot;</div><div class="line"></div><div class="line">for character in &quot;Dog!🐶&quot;.characters &#123;</div><div class="line">    print(character)</div><div class="line">&#125;</div><div class="line">// D</div><div class="line">// o</div><div class="line">// g</div><div class="line">// !</div><div class="line">// 🐶</div></pre></td></tr></table></figure>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let multiplier = 3</div><div class="line">let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意：</div><div class="line">插值字符串中写在括号中的表达式不能包含非转义反斜杠 (\)，并且不能包含回车或换行符。不过，插值字</div><div class="line">符串可以包含其他字面量。</div></pre></td></tr></table></figure>
<h3 id="Unicode标量"><a href="#Unicode标量" class="headerlink" title="Unicode标量"></a>Unicode标量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let dollarSign = &quot;\u&#123;24&#125;&quot;    // $, Unicode 标量 U+0024</div><div class="line">let blackHeart = &quot;\u&#123;2665&#125;&quot;  // ♥, Unicode 标量 U+2665</div><div class="line">let sparklingHeart = &quot;\u&#123;1F496&#125;&quot;// 💖, Unicode 标量U+1F496</div></pre></td></tr></table></figure>
<h3 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let unusualMenagerie = &quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;</div><div class="line">print(&quot;unusualMenagerie has \(unusualMenagerie.characters.count) characters&quot;)</div><div class="line">// 打印输出 &quot;unusualMenagerie has 40 characters&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意：</div><div class="line">Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。如果您正在处理一个长字符串，需要注意characters属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。</div><div class="line"></div><div class="line">characters.count并不总是等于NSString.length。NSString的length属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。</div></pre></td></tr></table></figure>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>字符串/字符可以用等于操作符(==)和不等于操作符(!=)表示值是否相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意：</div><div class="line">在 Swift 中，字符串和字符并不区分地域。</div></pre></td></tr></table></figure>
<h3 id="UTF-8表示"><a href="#UTF-8表示" class="headerlink" title="UTF-8表示"></a>UTF-8表示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for codeUnit in dogString.utf8 &#123;</div><div class="line">    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)</div><div class="line">&#125;</div><div class="line">print(&quot;&quot;)</div><div class="line">// 68 111 103 226 128 188 240 159 144 182</div></pre></td></tr></table></figure>
<h3 id="UTF-16表示"><a href="#UTF-16表示" class="headerlink" title="UTF-16表示"></a>UTF-16表示</h3><p><code>dogString.utf16</code></p>
<h3 id="Unicode-标量表示"><a href="#Unicode-标量表示" class="headerlink" title="Unicode 标量表示"></a>Unicode 标量表示</h3><p>您可以通过遍历String值的unicodeScalars属性来访问它的 Unicode 标量表示。 其为UnicodeScalarView类型的属性，UnicodeScalarView是UnicodeScalar类型的值的集合。<br><code>dogString. unicodeScalars</code></p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="三种集合类型"><a href="#三种集合类型" class="headerlink" title="三种集合类型"></a>三种集合类型</h3><p>Swift 语言提供<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>三种基本的集合类型用来存储集合数据。</p>
<h3 id="集合可变性"><a href="#集合可变性" class="headerlink" title="集合可变性"></a>集合可变性</h3><p>通过<code>let</code>和<code>var</code>区分是否可变</p>
<h3 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h3><p><code>var someInts = [Int]()</code></p>
<h3 id="创建一个带有默认值的数组"><a href="#创建一个带有默认值的数组" class="headerlink" title="创建一个带有默认值的数组"></a>创建一个带有默认值的数组</h3><p><code>var threeDoubles = Array(repeating: 0.0, count: 3)</code></p>
<h3 id="数组支持-和-运算符"><a href="#数组支持-和-运算符" class="headerlink" title="数组支持+和+=运算符"></a>数组支持+和+=运算符</h3><p>数组之间可以用<code>+</code>和<code>+=</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr_x = [1,2,3]</div><div class="line">arr_x += [4,5]</div></pre></td></tr></table></figure>
<h3 id="判断数组为空"><a href="#判断数组为空" class="headerlink" title="判断数组为空"></a>判断数组为空</h3><p><code>isEmpty</code>可以判断数组是否为空，其等价于<code>count==0</code></p>
<h3 id="可以用区间批量改变数组的值"><a href="#可以用区间批量改变数组的值" class="headerlink" title="可以用区间批量改变数组的值"></a>可以用区间批量改变数组的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr_x = [1,2,3]</div><div class="line">arr_x[1...2] = [10,10] //arr_x此时为[1,10,10]</div></pre></td></tr></table></figure>
<h3 id="用enumerated遍历数组"><a href="#用enumerated遍历数组" class="headerlink" title="用enumerated遍历数组"></a>用enumerated遍历数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (index, value) in shoppingList. enumerated() &#123;</div><div class="line">    print(&quot;Item \(String(index + 1)): \(value)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建和构造一个空的集合"><a href="#创建和构造一个空的集合" class="headerlink" title="创建和构造一个空的集合"></a>创建和构造一个空的集合</h3><p><code>var letters = Set&lt;Character&gt;()</code></p>
<h3 id="可以用数组字面量创建一个集合"><a href="#可以用数组字面量创建一个集合" class="headerlink" title="可以用数组字面量创建一个集合"></a>可以用数组字面量创建一个集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</div></pre></td></tr></table></figure>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><ul>
<li><code>intersection(_:)</code>取交集。</li>
<li><code>symmetricDifference(_:)</code>取不同。</li>
<li><code>union(_:)</code>取并集。</li>
<li><code>subtracting(_:)</code>取差集。</li>
<li><code>==</code>相等。</li>
<li><code>isSubset(of:)</code>是否是子集(包含相等情况)。</li>
<li><code>isSuperset(of:)</code>是否是父集(包含相等情况)。</li>
<li><code>isStrictSubset(of:)</code>是否是子集(不包含相等情况)。</li>
<li><code>isStrictSuperset(of:)</code>是否是父集(不包含相等情况)。</li>
<li><code>isDisjoint(with:)</code>是否没有交集。</li>
</ul>
<h3 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h3><p><code>var namesOfIntegers = [Int: String]()</code></p>
<h3 id="字典字面量"><a href="#字典字面量" class="headerlink" title="字典字面量"></a>字典字面量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var airports: [String: String] = </div><div class="line">[&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</div></pre></td></tr></table></figure>
<h3 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (airportCode, airportName) in airports &#123;</div><div class="line">    print(&quot;\(airportCode): \(airportName)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="使用匿名变量遍历"><a href="#使用匿名变量遍历" class="headerlink" title="使用匿名变量遍历"></a>使用匿名变量遍历</h3><p>当你不需要知道下标的时候，你可以使用如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var answer = 1</div><div class="line">let base = 3</div><div class="line">for _ in 1...100 &#123;</div><div class="line">    answer *= base</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置步长的遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for i in stride(from: 0, to: 10, by: 2) &#123;</div><div class="line">    print(i)</div><div class="line">    //会打印0，2，4，6，8，不会取到10，如果想取到10，那家写11</div><div class="line">&#125;</div><div class="line"></div><div class="line">for i in stride(from: 0, through: 10, by: 2) &#123;</div><div class="line">    print(i)</div><div class="line">    //会打印0，2，4，6，8，10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Repeat-While循环"><a href="#Repeat-While循环" class="headerlink" title="Repeat-While循环"></a>Repeat-While循环</h3><p>Swift语言的<code>repeat-while</code>循环和其他语言中的<code>do-while</code>循环是类似的。</p>
<h3 id="支持区间和组合的Switch"><a href="#支持区间和组合的Switch" class="headerlink" title="支持区间和组合的Switch"></a>支持区间和组合的Switch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let x = 3</div><div class="line">switch x &#123;</div><div class="line">case 0...4:</div><div class="line">    print(&quot;hello&quot;)</div><div class="line">case 5,6,7:</div><div class="line">    print(&quot;hey&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;what&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Switch中的元组"><a href="#Switch中的元组" class="headerlink" title="Switch中的元组"></a>Switch中的元组</h3><p>我们可以使用元组在同一个switch语句中测试多个值。元组中的元素可以是值，也可以是区间。另外，使用下划线（_）来匹配所有可能的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let tup = (3,10)</div><div class="line">switch tup &#123;</div><div class="line">case (0,0):</div><div class="line">    print(&quot;must be (0,0)&quot;)</div><div class="line">case (_,0):</div><div class="line">    print(&quot;such as (1,0),(2,0),(3,0)&quot;)</div><div class="line">case (3,_):</div><div class="line">    print(&quot;such as (3,10),(3,2)&quot;)</div><div class="line">case (5...7,2...8):</div><div class="line">    print(&quot;such as (5,2),(6,8),(7,3)&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;what&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Switch值绑定与where"><a href="#Switch值绑定与where" class="headerlink" title="Switch值绑定与where"></a>Switch值绑定与where</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let lettup = (1,-1)</div><div class="line">switch tup &#123;</div><div class="line">case let (x,y) where x == y:</div><div class="line">    print(&quot;such as (1,1),(2,2)&quot;)</div><div class="line">case let (x,_) where x &gt; 0:</div><div class="line">    print(&quot;such as (1,-1),(2,-8)&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;other&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Switch-For-Continue"><a href="#Switch-For-Continue" class="headerlink" title="Switch,For,Continue"></a>Switch,For,Continue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let arr_ = [3,4,5,6,7]</div><div class="line">for x in arr_ &#123;</div><div class="line">    switch x &#123;</div><div class="line">    case 5,7:</div><div class="line">        continue</div><div class="line">    default:</div><div class="line">        print(x)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Switch贯穿"><a href="#Switch贯穿" class="headerlink" title="Switch贯穿"></a>Switch贯穿</h3><p>C语言中，你必须显示的调用<code>break</code>，才能跳过其他的分支，而Swift刚好与之相反，只要匹配到了一个分支，<code>switch</code>就结束了，你可以通过在分支下面加入<code>fallthrough</code>来实现C语言的<code>switch</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var result = 0.0</div><div class="line">let intval = 66</div><div class="line">switch intval &#123;</div><div class="line">case 91...100:</div><div class="line">     result += Double(intval-90) * 1</div><div class="line">     fallthrough</div><div class="line">case 81...90:</div><div class="line">    result += Double(intval-80) * 0.8</div><div class="line">    fallthrough</div><div class="line">case 71...80:</div><div class="line">    result += Double(intval-70) * 0.6</div><div class="line">    fallthrough</div><div class="line">case 61...70:</div><div class="line">    result += Double(intval-60) * 0.4</div><div class="line">    fallthrough</div><div class="line">case 0...60:</div><div class="line">    result += Double(intval) * 0.2</div><div class="line">    fallthrough</div><div class="line">default:</div><div class="line">     result += Double(intval) * 0.4</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意： fallthrough关键字不会检查它下一个将会落入执行的 case 中的匹配条件。fallthrough简单</div><div class="line">地使代码继续连接到下一个 case 中的代码，这和 C 语言标准中的switch语句特性是一样的。</div></pre></td></tr></table></figure>
<h3 id="Continue-Break的标签"><a href="#Continue-Break的标签" class="headerlink" title="Continue,Break的标签"></a>Continue,Break的标签</h3><p>当你有多层嵌套循环的时候，你可以用<code>continue/break label</code>来实现跳过指定的循环层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var counts = 0</div><div class="line">externLoop : for i in 0...5 &#123;</div><div class="line">    for j in 0...6 &#123;</div><div class="line">        counts += 1</div><div class="line">        if j == 1 &amp;&amp; i &lt; 3&#123;</div><div class="line">            continue externLoop</div><div class="line">        &#125;</div><div class="line">        if j == 3 &#123;</div><div class="line">            break externLoop</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//0,0   0,1   1,0   1,1   2,0  2,1   3,0  3,1   3,2   3,3</div><div class="line">print(counts)  //count为10</div></pre></td></tr></table></figure>
<h3 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h3><p>不同于if语句，一个guard语句总是有一个else从句，如果条件不为真则执行else从句中的代码。(用于对允许值的过滤，往往不允许的值的条件，会让代码可读性变差，也有可能写漏)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func guard_func(obj:String?)&#123;</div><div class="line">    guard let name = obj else &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    //数值合法，做处理</div><div class="line">    print(obj)</div><div class="line">&#125;</div><div class="line">guard_func(obj: nil)</div><div class="line">guard_func(obj: &quot;hey&quot;)</div></pre></td></tr></table></figure>
<h3 id="available"><a href="#available" class="headerlink" title="#available"></a>#available</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if #available(iOS 10, macOS 10.1,*) &#123;</div><div class="line">    //iOS10的新特性</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func standard_func(name:String?,age:Int?) -&gt; Bool&#123;</div><div class="line">    if let _ = name,let _ = age&#123;</div><div class="line">        return true</div><div class="line">    &#125;</div><div class="line">    return false</div><div class="line">&#125;</div><div class="line">func void_func(name:String)&#123;</div><div class="line">    print(&quot;No Return Func&quot;)</div><div class="line">&#125;</div><div class="line">func void_void_func()&#123;</div><div class="line">    print(&quot;No Params No Return Func&quot;)</div><div class="line">&#125;</div><div class="line">func multi_return_func(arr:[Int]) -&gt; (min:Int?,max:Int?)&#123;</div><div class="line">    if arr.count == 0 &#123;</div><div class="line">        return (nil,nil)</div><div class="line">    &#125;</div><div class="line">    if arr.count == 1 &#123;</div><div class="line">        return (arr[0],arr[1])</div><div class="line">    &#125;</div><div class="line">    let max_value = arr.max(by: &gt;)</div><div class="line">    let min_value = arr.min(by: &lt;)</div><div class="line">    return (min_value,max_value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可选元组返回类型"><a href="#可选元组返回类型" class="headerlink" title="可选元组返回类型"></a>可选元组返回类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意 可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类</div><div class="line">型，整个元组是可选的，而不只是元组中的每个元素值。</div></pre></td></tr></table></figure>
<h3 id="指定参数标签"><a href="#指定参数标签" class="headerlink" title="指定参数标签"></a>指定参数标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func greet(person: String, from hometown: String)</div><div class="line"> -&gt; String &#123;</div><div class="line">    return &quot;Hello \(person)!  Glad you could visit from \(hometown).&quot;</div><div class="line">&#125;</div><div class="line">greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;)</div></pre></td></tr></table></figure>
<h3 id="忽略参数标签"><a href="#忽略参数标签" class="headerlink" title="忽略参数标签"></a>忽略参数标签</h3><p>如果你不希望为某个参数添加一个标签，可以使用一个下划线(_)来代替一个明确的参数标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123;</div><div class="line">     // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</div><div class="line">&#125;</div><div class="line">someFunction(1, secondParameterName: 2)</div></pre></td></tr></table></figure>
<h3 id="模式参数值"><a href="#模式参数值" class="headerlink" title="模式参数值"></a>模式参数值</h3><p>将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加的重要，将不带默认值的参数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func default_vaule_func(name:String,greet:String = &quot;Hello&quot;)&#123;</div><div class="line">    print(&quot;\(greet) \(name)&quot;)</div><div class="line">&#125;</div><div class="line">default_vaule_func(name: &quot;张三&quot;)</div><div class="line">default_vaule_func(name: &quot;李四&quot;, greet: &quot;Hi&quot;)</div></pre></td></tr></table></figure>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func avg_func(_ numbers: Double...) -&gt; Double &#123;</div><div class="line">    var total: Double = 0</div><div class="line">    for number in numbers &#123;</div><div class="line">        total += number</div><div class="line">    &#125;</div><div class="line">    return total / Double(numbers.count)</div><div class="line">&#125;</div><div class="line">avg_func(1, 2, 3, 4, 5)</div><div class="line"></div><div class="line">注意：</div><div class="line">一个函数最多只能拥有一个可变参数。</div></pre></td></tr></table></figure>
<h3 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123;</div><div class="line">    let temporaryA = a</div><div class="line">    a = b</div><div class="line">    b = temporaryA</div><div class="line">&#125;</div><div class="line"></div><div class="line">var someInt = 3</div><div class="line">var anotherInt = 107</div><div class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</div><div class="line">print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)</div><div class="line">// 打印 &quot;someInt is now 107, and anotherInt is now 3&quot;</div></pre></td></tr></table></figure>
<h3 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var mathFunction: (Int, Int) -&gt; Int = addTwoInts</div><div class="line"></div><div class="line">func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123;</div><div class="line">    print(&quot;Result: \(mathFunction(a, b))&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</div><div class="line">    return backward ? stepBackward : stepForward</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</div><div class="line">    func stepForward(input: Int) -&gt; Int &#123;</div><div class="line">     return input + 1</div><div class="line">    &#125;</div><div class="line">    func stepBackward(input: Int) -&gt; Int &#123;</div><div class="line">     return input - 1 </div><div class="line">    &#125;</div><div class="line">    return backward ? stepBackward : stepForward</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in</div><div class="line">    return s1 &gt; s2</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h3><p>如果<code>sorted(by:)</code>方法被一个字符串数组调用，其参数就必须是<code>(String, String) -&gt; Bool</code>类型的函数。这意味着<code>(String, String)</code>和<code>Bool</code>可以省略。返回箭头<code>-&gt;</code>和围绕在参数周围的括号也可以被省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: </div><div class="line">&#123; s1, s2 in return s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
<h3 id="单表达式闭包隐式返回"><a href="#单表达式闭包隐式返回" class="headerlink" title="单表达式闭包隐式返回"></a>单表达式闭包隐式返回</h3><p>单行表达式闭包可以通过省略<code>return</code>关键字来隐式返回单行表达式的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
<h3 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h3><p>swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</div></pre></td></tr></table></figure>
<h3 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h3><p>实际上还有一种更简短的方式来编写上面例子中的闭包表达式。Swift 的<code>String</code>类型定义了关于大于号<code>&gt;</code>的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与 <code>sorted(by:)</code>方法的参数需要的函数类型相符合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &gt;)</div></pre></td></tr></table></figure>
<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted() &#123; $0 &gt; $1 &#125;</div><div class="line">reversedNames = names.sorted &#123; $0 &gt; $1 &#125;</div></pre></td></tr></table></figure>
<h3 id="闭包逃逸"><a href="#闭包逃逸" class="headerlink" title="闭包逃逸"></a>闭包逃逸</h3><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，，你可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var c_arr = [() -&gt; Void]()</div><div class="line">func test_escape(closure:@escaping () -&gt; Void) &#123;</div><div class="line">    c_arr.append(closure)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你不将这个参数标记为<code>@escaping</code>，就会得到一个编译错误。<br>将一个闭包标记为<code>@escaping</code>意味着你必须在闭包中显式地引用<code>self</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func test_no_escape(closure:() -&gt; Void) &#123;</div><div class="line">    closure()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SomeClass &#123;</div><div class="line">    var x = 10</div><div class="line">    func doSomething() &#123;</div><div class="line">        test_escape &#123; </div><div class="line">        self.x = 100 &#125;</div><div class="line">        test_no_escape &#123; </div><div class="line">        x = 200 &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。你能够省略闭包的花括号，用一个普通的表达式来代闭包。这种闭包只需要在冒号后面添加<code>@autoclosure</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var customersInLine = [&quot;Susan&quot;,&quot;Judy&quot;,&quot;Micheal&quot;]</div><div class="line">func serve(customer customerProvider: </div><div class="line">@autoclosure () -&gt; String) &#123; //自动闭包</div><div class="line">    print(&quot;Now serving \(customerProvider())!&quot;)</div><div class="line">&#125;</div><div class="line">serve(customer: customersInLine.remove(at: 0)) //不需要写大括号</div><div class="line">//serve(customer: &#123; customersInLine.remove(at: 0) &#125; )  非自动闭包需要加大括号</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意 </div><div class="line">过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是</div><div class="line">被延迟执行的。</div></pre></td></tr></table></figure>
<p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用<code>@autoclosure</code>和<code>@escaping</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var customerProviders: [() -&gt; String] = []</div><div class="line">func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123;</div><div class="line">    customerProviders.append(customerProvider)</div><div class="line">&#125;</div><div class="line">collectCustomerProviders(customersInLine.remove(at: 0))</div><div class="line">collectCustomerProviders(customersInLine.remove(at: 0))</div></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum CompassPoint &#123;</div><div class="line">    case north</div><div class="line">    case south</div><div class="line">    case east</div><div class="line">    case west</div><div class="line">&#125;</div><div class="line"></div><div class="line">var directionToHead = CompassPoint.west</div><div class="line">directionToHead = .east</div><div class="line">let directionToHead2:CompassPoint = .north</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。这些枚举成员本身就是完备的值，这些值的类</div><div class="line">型是已经明确定义好的CompassPoint类型。</div></pre></td></tr></table></figure>
<p>当<code>directionToHead</code>的类型已知时，再次为其赋值可以省略枚举类型名。</p>
<p>###多个值可以出现在同一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum Planet &#123;</div><div class="line">    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用-Switch-语句匹配枚举值"><a href="#使用-Switch-语句匹配枚举值" class="headerlink" title="使用 Switch 语句匹配枚举值"></a>使用 Switch 语句匹配枚举值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">directionToHead = .south</div><div class="line">switch directionToHead &#123;</div><div class="line">    case .north:</div><div class="line">        print(&quot;Lots of planets have a north&quot;)</div><div class="line">    case .south:</div><div class="line">        print(&quot;Watch out for penguins&quot;)</div><div class="line">    case .east:</div><div class="line">        print(&quot;Where the sun rises&quot;)</div><div class="line">    case .west:</div><div class="line">        print(&quot;Where the skies are blue&quot;)</div><div class="line">&#125;</div><div class="line">// 打印 &quot;Watch out for penguins”</div></pre></td></tr></table></figure>
<p>switch语句必须穷举所有情况。如果忽略了.west这种情况，上面那段代码将无法通过编译。<br>当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：</p>
<h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">enum GoodsCode &#123;</div><div class="line">    case qrCode(String)</div><div class="line">    case upc(Int,Int,Int,Int)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var code:GoodsCode = .upc(8, 8, 8, 8)</div><div class="line">code = .qrCode(&quot;ABCDEF&quot;)</div><div class="line"></div><div class="line">switch code &#123;</div><div class="line">case let .upc(a,b,c,d):</div><div class="line">    print(&quot;\(a),\(b),\(c),\(d)&quot;)</div><div class="line">case .qrCode(let codeStr):</div><div class="line">    print(codeStr)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个枚举成员的所有关联值都被提取为常量，你可以只在成员名称前标注一个let或者var</p>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum ASCIIControlCharacter: Character &#123;</div><div class="line">    case tab = &quot;\t&quot;</div><div class="line">    case lineFeed = &quot;\n&quot;</div><div class="line">    case carriageReturn = &quot;\r&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">注意</div><div class="line">原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定</div><div class="line">的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员</div><div class="line">的关联值可以变化。</div></pre></td></tr></table></figure>
<h3 id="原始值的隐式赋值"><a href="#原始值的隐式赋值" class="headerlink" title="原始值的隐式赋值"></a>原始值的隐式赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum Planet: Int &#123;</div><div class="line">    case mercury = 1, venus, earth, mars,</div><div class="line">     jupiter, saturn, uranus, neptune</div><div class="line">&#125;</div><div class="line"></div><div class="line">let earthsOrder = Planet.earth.rawValue</div></pre></td></tr></table></figure>
<p>在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。</p>
<h3 id="使用原始值初始化枚举实例"><a href="#使用原始值初始化枚举实例" class="headerlink" title="使用原始值初始化枚举实例"></a>使用原始值初始化枚举实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let possiblePlanet = Planet(rawValue: 7)</div><div class="line">// possiblePlanet 类型为 Planet? 值为 Planet.uranus</div><div class="line">// 如果原始值不存在则返回nil</div></pre></td></tr></table></figure>
<h3 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h3><p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum MathExp &#123;</div><div class="line">    case number(Int)</div><div class="line">    indirect case add(MathExp, MathExp)</div><div class="line">    indirect case mul(MathExp, MathExp)</div><div class="line">    indirect case sub(MathExp, MathExp)</div><div class="line">    indirect case div(MathExp, MathExp)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在枚举类型开头加上<code>indirect</code>关键字来表明它的所有成员都是可递归的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">indirect enum MathExp &#123;</div><div class="line">    case number(Int)</div><div class="line">    case addition(MathExp, MathExp)</div><div class="line">    case multiplication(MathExp, MathExp)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如，表达式(5 + 4) * 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。</p>
<p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func evaluate(_ expression: MathExp) -&gt; Int &#123;</div><div class="line">    switch expression &#123;</div><div class="line">    case let .number(value):</div><div class="line">        return value</div><div class="line">    case let .addition(left, right):</div><div class="line">        return evaluate(left) + evaluate(right)</div><div class="line">    case let .multiplication(left, right):</div><div class="line">        return evaluate(left) * evaluate(right)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(evaluate(product))</div><div class="line">// 打印 &quot;18&quot;</div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h3><p>共同点:  </p>
<ul>
<li>定义属性  </li>
<li>定义方法  </li>
<li>定义下标  </li>
<li>定义构造器</li>
<li>定义扩展</li>
<li>实现协议  </li>
</ul>
<p>类还有如下的附加功能：</p>
<ul>
<li>可以继承</li>
<li>类型转换</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">结构体总是值传递，不存在引用计数。</div></pre></td></tr></table></figure>
<h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct Resolution &#123;</div><div class="line">    var width = 0</div><div class="line">    var height = 0</div><div class="line">&#125;</div><div class="line">class VideoMode &#123;</div><div class="line">    var resolution = Resolution()</div><div class="line">    var interlaced = false</div><div class="line">    var frameRate = 0.0</div><div class="line">    var name: String?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Swift 允许直接设置结构体属性的子属性。不需要重新为整结构体设置新值。</p>
<h3 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let vga = Resolution(width:640, height: 480)</div></pre></td></tr></table></figure>
<h3 id="结构体和枚举是值类型-类是引用类型"><a href="#结构体和枚举是值类型-类是引用类型" class="headerlink" title="结构体和枚举是值类型,类是引用类型"></a>结构体和枚举是值类型,类是引用类型</h3><h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><ul>
<li>等价于（<code>===</code>）</li>
<li>不等价于（<code>!==</code>）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f tenEighty === alsoTenEighty &#123;</div><div class="line">    print(&quot;tenEighty and alsoTenEighty refer to the same Resolution instance.&quot;)</div><div class="line">&#125;</div><div class="line">//打印 &quot;tenEighty and alsoTenEighty refer to the same Resolution instance.&quot;</div></pre></td></tr></table></figure>
<p>请注意，“等价于”（用三个等号表示，<code>===</code>）与“等于”（用两个等号表示，<code>==</code>）的不同：</p>
<ul>
<li>“等价于”表示两个类对象（<code>class</code>）的地址相等。</li>
<li>“等于”表示两个变量的值 (任何类型)“相等”或“相同”，判断逻辑可由开发者决定。</li>
</ul>
<h3 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h3><p>何时用类：</p>
<ul>
<li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>
<li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
<li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>
<li>该数据结构不需要去继承另一个既有类型的属性或者行为。</li>
</ul>
<p>何时用结构体：</p>
<ul>
<li>几何形状的大小，封装一个<code>width</code>属性和<code>height</code>属性，两者均为<code>Double</code>类型。</li>
<li>一定范围内的路径，封装一个<code>start</code>属性和<code>length</code>属性，两者均为<code>Int</code>类型。</li>
<li>三维坐标系内一点，封装<code>x</code>，<code>y</code>和<code>z</code>属性，三者均为<code>Double</code>类型。</li>
</ul>
<h3 id="字符串、数组、和字典类型的赋值与复制行为"><a href="#字符串、数组、和字典类型的赋值与复制行为" class="headerlink" title="字符串、数组、和字典类型的赋值与复制行为"></a>字符串、数组、和字典类型的赋值与复制行为</h3><p>Swift 中，许多基本类型，诸如<code>String</code>，<code>Array</code>和<code>Dictionary</code>类型均以结构体的形式实现。它们都是值传递。而对应的OC中的类型(<code>NSString</code>等)都是类类型，通过引用传递。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><p>用<code>lazy</code>可以声明一个延迟特性的存储属性，延迟属性第一次调用才会付初值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class DataManager &#123;</div><div class="line">    lazy var importer = DataImporter()</div><div class="line">    var data = [String]()</div><div class="line">    // 这里会提供数据管理功能</div><div class="line">&#125;</div><div class="line"></div><div class="line">注意</div><div class="line">延迟属性必须是变量(var),因为它赋值在构造之后。</div><div class="line">lazy属于不是线程安全的。</div></pre></td></tr></table></figure>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>可以通过<code>getter</code>和<code>setter</code>为类，结构体和枚举定义计算属性。计算属性不存储值，而是通过<code>getter</code>，<code>setter</code>管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">struct Point &#123;</div><div class="line">    var x = 0.0, y = 0.0</div><div class="line">&#125;</div><div class="line">struct Size &#123;</div><div class="line">    var width = 0.0, height = 0.0</div><div class="line">&#125;</div><div class="line">struct Rect &#123;</div><div class="line">    var origin = Point()</div><div class="line">    var size = Size()</div><div class="line">    var center: Point &#123;</div><div class="line">        get &#123;</div><div class="line">            let centerX = origin.x + (size.width / 2)</div><div class="line">            let centerY = origin.y + (size.height / 2)</div><div class="line">            return Point(x: centerX, y: centerY)</div><div class="line">        &#125;</div><div class="line">        set(newCenter) &#123;</div><div class="line">            origin.x = newCenter.x - (size.width / 2)</div><div class="line">            origin.y = newCenter.y - (size.height / 2)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="简化Setter"><a href="#简化Setter" class="headerlink" title="简化Setter"></a>简化Setter</h3><p><code>setter</code>可以省略参数，使用默认名称 <code>newValue</code>s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set &#123;</div><div class="line">    origin.x = newValue.x - (size.width / 2)</div><div class="line">    origin.y = newValue.y - (size.height / 2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h3><p>只读计算属性，只有<code>getter</code>。它可以通过点运算符访问，但不能设置新的值。<br>只读计算属性的声明可以去掉 <code>get</code> 关键字和花括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Cuboid &#123;</div><div class="line">    var width = 0.0, height = 0.0, depth = 0.0</div><div class="line">    var volume: Double &#123;</div><div class="line">        return width * height * depth</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)</div><div class="line">print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)</div><div class="line">// 打印 &quot;the volume of fourByFiveByTwo is 40.0&quot;</div></pre></td></tr></table></figure>
<h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><ul>
<li><code>willSet</code> 在新的值被设置之前调用</li>
<li><code>didSet</code> 在新的值被设置之后立即调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">父类的属性在子类的构造器中被赋值时，先调用父类观察器，后调用子类的观察器。在父类初始化方法调用之前(属性被赋值)，观察器不会被调用。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class StepCounter &#123;</div><div class="line">    var totalSteps: Int = 0 &#123;</div><div class="line">        willSet(newTotalSteps) &#123;</div><div class="line">            print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)</div><div class="line">        &#125;</div><div class="line">        didSet &#123;</div><div class="line">            if totalSteps &gt; oldValue  &#123;</div><div class="line">                print(&quot;Added \(totalSteps - oldValue) steps&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line"></div><div class="line">如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用</div><div class="line">了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</div></pre></td></tr></table></figure>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>全局变量和局部变量，都可以添加属性观察器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">全局的常量或变量都是延迟计算的，不需要标记lazy修饰符。</div><div class="line">局部范围的常量或变量从不延迟计算。</div></pre></td></tr></table></figure>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>类属性，不论有多少个实例，属性都只有一份。<br>它用于定义某个类型共享的数据。<br>存储类属性可以是变量或常量，计算类属性只能定义成变量属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">类属性必须给存储型类型属性指定默认值，因为类型本身没有构造器，所以无法使用构造器。</div><div class="line">存储型类属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化，并且不需要对其使用 lazy 修饰符。</div></pre></td></tr></table></figure>
<h3 id="类型属性语法"><a href="#类型属性语法" class="headerlink" title="类型属性语法"></a>类型属性语法</h3><p>类属性支持<code>struct</code> <code>enum</code> <code>class</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct SomeStructure &#123;</div><div class="line">    static var storedTypeProperty = &quot;Some value.&quot;</div><div class="line">    static var computedTypeProperty: Int &#123;</div><div class="line">        return 1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相</div><div class="line">同。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct AudioChannel &#123;</div><div class="line">    static let thresholdLevel = 10</div><div class="line">    static var maxInputLevelForAllChannels = 0</div><div class="line">    var currentLevel: Int = 0 &#123;</div><div class="line">        didSet &#123;</div><div class="line">            if currentLevel &gt; AudioChannel.thresholdLevel &#123;</div><div class="line">                // 将当前音量限制在阈值之内</div><div class="line">                currentLevel = AudioChannel.thresholdLevel</div><div class="line">            &#125;</div><div class="line">            if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels &#123;</div><div class="line">                // 存储当前音量作为新的最大输入音量</div><div class="line">                AudioChannel.maxInputLevelForAllChannels = currentLevel</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">didSet中改变属性，不会造成死循环。</div></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="在实例方法中修改值类型"><a href="#在实例方法中修改值类型" class="headerlink" title="在实例方法中修改值类型"></a>在实例方法中修改值类型</h3><p>结构体和枚举要想在方法中改变属性必须用<code>mutating</code>修饰（默认是不能改的，因为是值类型），在方法中甚至，可以改变self的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct Point &#123;</div><div class="line">    var x = 0.0, y = 0.0</div><div class="line">    mutating func moveByX(deltaX: Double, y deltaY: Double) &#123;</div><div class="line">        x += deltaX</div><div class="line">        y += deltaY</div><div class="line">        //self = Point(x: x + deltaX, y: y + deltaY)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>通过<code>static</code>可以定义一个类方法。类还可以用关键字<code>class</code>来允许子类重写父类的方法实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">类、结构体、枚举都可以定义’类方法‘。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class SomeClass &#123;</div><div class="line">    class func someTypeMethod() &#123;</div><div class="line">        // 在这里实现类型方法</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">SomeClass.someTypeMethod()</div></pre></td></tr></table></figure>
<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><h3 id="定义下标属性"><a href="#定义下标属性" class="headerlink" title="定义下标属性"></a>定义下标属性</h3><p>可以用<code>subscript</code>关键字来定义下标方法，下标还可以设定读写权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">subscript(index: Int) -&gt; Int &#123;</div><div class="line">    get &#123;</div><div class="line">      // 返回一个适当的 Int 类型的值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set(newValue) &#123;</div><div class="line">      // 执行适当的赋值操作</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="下标选项"><a href="#下标选项" class="headerlink" title="下标选项"></a>下标选项</h3><p>下标可以接受任意数量的入参，并且这些入参可以是任意类型，下标的返回值也可以是任意类型。<br>下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。<br>类或结构体可以提供多个下标实现并且支持重载。<br>重写<code>indexIsValidForRow</code>方法可以判断下标是否合法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct Matrix &#123;</div><div class="line">    let rows: Int, columns: Int</div><div class="line">    var grid: [Double]</div><div class="line">    init(rows: Int, columns: Int) &#123;</div><div class="line">        self.rows = rows</div><div class="line">        self.columns = columns</div><div class="line">        grid = Array(count: rows * columns, repeatedValue: 0.0)</div><div class="line">    &#125;</div><div class="line">    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123;</div><div class="line">        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns</div><div class="line">    &#125;</div><div class="line">    subscript(row: Int, column: Int) -&gt; Double &#123;</div><div class="line">        get &#123;</div><div class="line">            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)</div><div class="line">            return grid[(row * columns) + column]</div><div class="line">        &#125;</div><div class="line">        set &#123;</div><div class="line">            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)</div><div class="line">            grid[(row * columns) + column] = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Bicycle: Vehicle &#123;</div><div class="line">    var hasBasket = false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>可以重写继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。</p>
<p>如果要重写，需要加上<code>override</code>关键字。<br>任何缺少<code>override</code>关键字的重写都会在编译时被诊断为错误。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>在合适的地方，你可以通过使用<code>super</code>前缀来调用父类的方法，属性或下标：</p>
<ul>
<li><code>super.someMethod()</code>调用父类方法</li>
<li><code>super.someProperty</code>调用父类属性</li>
<li><code>super[someIndex]</code>调用父类的下标方法</li>
</ul>
<h3 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h3><p>你可以重写继承来的实例属性或类属性，提供自己定制的<code>getter</code>和<code>setter</code>,<code>willSet</code>,<code>didSet</code>。</p>
<p>重写一个属性时，必需将它的名字和类型都写出来。</p>
<p>你可以将一个继承来的只读属性重写为一个读写属性。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Car: Vehicle &#123;</div><div class="line">    var gear = 1</div><div class="line">    override var description: String &#123;</div><div class="line">        return super.description + &quot; in gear \(gear)&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中</div><div class="line">的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，</div><div class="line">其中someProperty是你要重写的属性的名字。</div></pre></td></tr></table></figure>
<p>你可以通过重写属性为一个继承来的属性添加属性观察器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设</div><div class="line">置的，所以，为它们提供willSet或didSet实现是不恰当。  </div><div class="line">你不可以同时提供重写的 setter 和重写的属性观察器。你可以在setter中实现属性观察的效果。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class AutomaticCar: Car &#123;</div><div class="line">    override var currentSpeed: Double &#123;</div><div class="line">        didSet &#123;</div><div class="line">            gear = Int(currentSpeed / 10.0) + 1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h3><p>通过<code>final</code>关键字防止方法，属性或下标被重写（例如：<code>final var</code>，<code>final func</code>，<code>final class func</code>，以及<code>final subscript</code>）。</p>
<p>重写<code>final</code>属性或下标，在编译时会报错。</p>
<p>通过<code>final</code>在关键字防止类被继承，试图继承这样的类会导致编译报错。</p>
<h2 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h2><h3 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h3><p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>
<p>你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察</div><div class="line">者。</div></pre></td></tr></table></figure>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init() &#123;</div><div class="line">    // 在此处执行构造过程</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参数的内部名称和外部名称"><a href="#参数的内部名称和外部名称" class="headerlink" title="参数的内部名称和外部名称"></a>参数的内部名称和外部名称</h3><p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct Color &#123;</div><div class="line">    let red, green, blue: Double</div><div class="line">    init(red: Double, green: Double, blue: Double) &#123;</div><div class="line">        self.red   = red</div><div class="line">        self.green = green</div><div class="line">        self.blue  = blue</div><div class="line">    &#125;</div><div class="line">    init(white: Double) &#123;</div><div class="line">        red   = white</div><div class="line">        green = white</div><div class="line">        blue  = white</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 报编译时错误，需要外部名称</div><div class="line">let veryGreen = Color(0.0, 1.0, 0.0)</div></pre></td></tr></table></figure>
<h3 id="不带外部名的构造器参数"><a href="#不带外部名的构造器参数" class="headerlink" title="不带外部名的构造器参数"></a>不带外部名的构造器参数</h3><p>你可以使用下划线(_)来省略参数的外部名，以此重写上面所说的默认行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct Celsius &#123;</div><div class="line">    var temperatureInCelsius: Double</div><div class="line">    init(fromFahrenheit fahrenheit: Double) &#123;</div><div class="line">        temperatureInCelsius = (fahrenheit - 32.0) / 1.8</div><div class="line">    &#125;</div><div class="line">    init(fromKelvin kelvin: Double) &#123;</div><div class="line">        temperatureInCelsius = kelvin - 273.15</div><div class="line">    &#125;</div><div class="line">    init(_ celsius: Double)&#123;</div><div class="line">        temperatureInCelsius = celsius</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let bodyTemperature = Celsius(37.0)</div><div class="line">// bodyTemperature.temperatureInCelsius 为 37.0</div></pre></td></tr></table></figure>
<h3 id="构造过程中常量属性的修改"><a href="#构造过程中常量属性的修改" class="headerlink" title="构造过程中常量属性的修改"></a>构造过程中常量属性的修改</h3><p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</div></pre></td></tr></table></figure>
<h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（<code>default initializers</code>）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ShoppingListItem &#123;</div><div class="line">    var name: String?</div><div class="line">    var quantity = 1</div><div class="line">    var purchased = false</div><div class="line">&#125;</div><div class="line">var item = ShoppingListItem()</div></pre></td></tr></table></figure>
<p>尽管代码中没有显式为name属性设置默认值，但由于name是可选字符串类型，它将默认设置为nil</p>
<h3 id="结构体的逐一成员构造器"><a href="#结构体的逐一成员构造器" class="headerlink" title="结构体的逐一成员构造器"></a>结构体的逐一成员构造器</h3><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Size &#123;</div><div class="line">    var width = 0.0, height = 0.0</div><div class="line">&#125;</div><div class="line">let twoByTwo = Size(width: 2.0, height: 2.0)</div></pre></td></tr></table></figure>
<h3 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h3><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct Rect &#123;</div><div class="line">    var origin = Point()</div><div class="line">    var size = Size()</div><div class="line">    init() &#123;&#125;</div><div class="line">    init(origin: Point, size: Size) &#123;</div><div class="line">        self.origin = origin</div><div class="line">        self.size = size</div><div class="line">    &#125;</div><div class="line">    init(center: Point, size: Size) &#123;</div><div class="line">        let originX = center.x - (size.width / 2)</div><div class="line">        let originY = center.y - (size.height / 2)</div><div class="line">        self.init(origin: Point(x: originX, y: originY), size: size)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后,仍然有人错误的使用自动生成的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造</div><div class="line">器写到扩展（extension）中，而不是写在值类型的原始定义中。想查看更多内容，请查看扩展章节。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">如果你想用另外一种不需要自己定义init()和init(origin:size:)的方式来实现这个例子，请参考扩展。</div></pre></td></tr></table></figure>
<h3 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h3><p>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。</p>
<h3 id="指定构造器和便利构造器"><a href="#指定构造器和便利构造器" class="headerlink" title="指定构造器和便利构造器"></a>指定构造器和便利构造器</h3><p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。</p>
<p>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p>
<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">init(parameters) &#123;</div><div class="line">    statements</div><div class="line">&#125;</div><div class="line"></div><div class="line">//便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字，</div><div class="line">并使用空格将它们俩分开：</div><div class="line"></div><div class="line">convenience init(parameters) &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类的构造器代理规则"><a href="#类的构造器代理规则" class="headerlink" title="类的构造器代理规则"></a>类的构造器代理规则</h3><p>规则 1</p>
<p>指定构造器必须调用其直接父类的的指定构造器。</p>
<p>规则 2</p>
<p>便利构造器必须调用同类中定义的其它构造器。</p>
<p>规则 3</p>
<p>便利构造器必须最终导致一个指定构造器被调用。</p>
<p>一个更方便记忆的方法是：</p>
<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则</div><div class="line">只影响类定义如何实现。</div></pre></td></tr></table></figure>
<h3 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h3><ul>
<li>每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后。</li>
<li>它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C </div><div class="line">给每一个属性赋值0或空值（比如说0或nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始</div><div class="line">值，并自如应对某些属性不能以0或nil作为合法默认值的情况。</div></pre></td></tr></table></figure>
<p>安全检查 1</p>
<p>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</p>
<p>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</p>
<p>安全检查 2</p>
<p>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>
<p>安全检查 3</p>
<p>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</p>
<p>安全检查 4</p>
<p>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</p>
<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。</p>
<p>阶段 1</p>
<ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>
</ul>
<p>阶段 2</p>
<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。</li>
</ul>
<h3 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h3><p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">父类的构造器仅会在安全和适当的情况下被继承。</div></pre></td></tr></table></figure>
<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">当你重写一个父类的指定构造器时，你总是需要写override修饰符，即使你的子类将父类的指定构造器重写</div><div class="line">为了便利构造器。</div></pre></td></tr></table></figure>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述），因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Vehicle &#123;</div><div class="line">    var numberOfWheels = 0</div><div class="line">    var description: String &#123;</div><div class="line">        return &quot;\(numberOfWheels) wheel(s)&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bicycle: Vehicle &#123;</div><div class="line">    override init() &#123;</div><div class="line">        super.init()</div><div class="line">        numberOfWheels = 2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。</div></pre></td></tr></table></figure>
<h3 id="构造器的自动继承"><a href="#构造器的自动继承" class="headerlink" title="构造器的自动继承"></a>构造器的自动继承</h3><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。</p>
<p>规则 1</p>
<p>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</p>
<p>规则 2</p>
<p>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。</p>
<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</div></pre></td></tr></table></figure>
<h3 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h3><p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。</p>
<p>其语法为在init关键字后面添加问号(init?)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</div></pre></td></tr></table></figure>
<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过return nil语句来表明可失败构造器在何种情况下应该“失败”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Animal &#123;</div><div class="line">    let species: String</div><div class="line">    init?(species: String) &#123;</div><div class="line">        if species.isEmpty &#123; return nil &#125;</div><div class="line">        self.species = species</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="枚举类型的可失败构造器"><a href="#枚举类型的可失败构造器" class="headerlink" title="枚举类型的可失败构造器"></a>枚举类型的可失败构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">enum TemperatureUnit &#123;</div><div class="line">    case Kelvin, Celsius, Fahrenheit</div><div class="line">    init?(symbol: Character) &#123;</div><div class="line">        switch symbol &#123;</div><div class="line">        case &quot;K&quot;:</div><div class="line">            self = .Kelvin</div><div class="line">        case &quot;C&quot;:</div><div class="line">            self = .Celsius</div><div class="line">        case &quot;F&quot;:</div><div class="line">            self = .Fahrenheit</div><div class="line">        default:</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="带原始值的枚举类型的可失败构造器"><a href="#带原始值的枚举类型的可失败构造器" class="headerlink" title="带原始值的枚举类型的可失败构造器"></a>带原始值的枚举类型的可失败构造器</h3><p>带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">enum TemperatureUnit: Character &#123;</div><div class="line">    case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let unknownUnit = TemperatureUnit(rawValue: &quot;X&quot;)</div><div class="line">if unknownUnit == nil &#123;</div><div class="line">    print(&quot;This is not a defined temperature unit, so initialization failed.&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造失败的传递"><a href="#构造失败的传递" class="headerlink" title="构造失败的传递"></a>构造失败的传递</h3><p>可失败构造器可以横向或者纵向代理。</p>
<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的</div><div class="line">构造过程中。</div></pre></td></tr></table></figure>
<h3 id="重写一个可失败构造器"><a href="#重写一个可失败构造器" class="headerlink" title="重写一个可失败构造器"></a>重写一个可失败构造器</h3><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>
<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">你可以用非可失败构造器重写可失败构造器，但反过来却不行。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Document &#123;</div><div class="line">    var name: String?</div><div class="line">    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例</div><div class="line">    init() &#123;&#125;</div><div class="line">    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例</div><div class="line">    init?(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        if name.isEmpty &#123; return nil &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class AutomaticallyNamedDocument: Document &#123;</div><div class="line">    override init() &#123;</div><div class="line">        super.init()</div><div class="line">        self.name = &quot;[Untitled]&quot;</div><div class="line">    &#125;</div><div class="line">    override init(name: String) &#123;</div><div class="line">        super.init()</div><div class="line">        if name.isEmpty &#123;</div><div class="line">            self.name = &quot;[Untitled]&quot;</div><div class="line">        &#125; else &#123;</div><div class="line">            self.name = name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class UntitledDocument: Document &#123;</div><div class="line">    override init() &#123;</div><div class="line">        super.init(name: &quot;[Untitled]&quot;)!</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="init"><a href="#init" class="headerlink" title="init!"></a>init!</h3><p>通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>
<p>你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。</p>
<h3 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h3><p>在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SomeClass &#123;</div><div class="line">    required init() &#123;</div><div class="line">        // 构造器的实现代码</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SomeSubclass: SomeClass &#123;</div><div class="line">    required init() &#123;</div><div class="line">        // 构造器的实现代码</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。</div></pre></td></tr></table></figure>
<h3 id="通过闭包或函数设置属性的默认值"><a href="#通过闭包或函数设置属性的默认值" class="headerlink" title="通过闭包或函数设置属性的默认值"></a>通过闭包或函数设置属性的默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class SomeClass &#123;</div><div class="line">    let someProperty: SomeType = &#123;</div><div class="line">        // 在这个闭包中给 someProperty 创建一个默认值</div><div class="line">        // someValue 必须和 SomeType 类型相同</div><div class="line">        return someValue</div><div class="line">    &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭</div><div class="line">包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。</div></pre></td></tr></table></figure>
<h2 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h2><h3 id="析构语法"><a href="#析构语法" class="headerlink" title="析构语法"></a>析构语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deinit &#123;</div><div class="line">    // 执行析构过程</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h2><h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line">    init(name: String) &#123; self.name = name &#125;</div><div class="line">    var apartment: Apartment?</div><div class="line">    deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Apartment &#123;</div><div class="line">    let unit: String</div><div class="line">    init(unit: String) &#123; self.unit = unit &#125;</div><div class="line">    weak var tenant: Person?</div><div class="line">    deinit &#123; print(&quot;Apartment \(unit) is being deinitialized&quot;) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">当 ARC 设置弱引用为nil时，属性观察不会被触发。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发</div><div class="line">垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并</div><div class="line">不适合上面的用途。</div></pre></td></tr></table></figure>
<h3 id="无主引用"><a href="#无主引用" class="headerlink" title="无主引用"></a>无主引用</h3><p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">重要</div><div class="line">使用无主引用，你必须确保引用始终指向一个未销毁的实例。</div><div class="line">如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。</div></pre></td></tr></table></figure>
<p>由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Customer &#123;</div><div class="line">    let name: String</div><div class="line">    var card: CreditCard?</div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">    &#125;</div><div class="line">    deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CreditCard &#123;</div><div class="line">    let number: UInt64</div><div class="line">    unowned let customer: Customer</div><div class="line">    init(number: UInt64, customer: Customer) &#123;</div><div class="line">        self.number = number</div><div class="line">        self.customer = customer</div><div class="line">    &#125;</div><div class="line">    deinit &#123; print(&quot;Card #\(number) is being deinitialized&quot;) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的</div><div class="line">原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全</div><div class="line">性。 你可以通过unowned(unsafe)来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不</div><div class="line">安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。</div></pre></td></tr></table></figure>
<h3 id="无主引用以及隐式解析可选属性"><a href="#无主引用以及隐式解析可选属性" class="headerlink" title="无主引用以及隐式解析可选属性"></a>无主引用以及隐式解析可选属性</h3><p>Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p>Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Country &#123;</div><div class="line">    let name: String</div><div class="line">    var capitalCity: City!</div><div class="line">    init(name: String, capitalName: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.capitalCity = City(name: capitalName, country: self)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class City &#123;</div><div class="line">    let name: String</div><div class="line">    unowned let country: Country</div><div class="line">    init(name: String, country: Country) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.country = country</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="闭包引起的循环强引用"><a href="#闭包引起的循环强引用" class="headerlink" title="闭包引起的循环强引用"></a>闭包引起的循环强引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">lass HTMLElement &#123;</div><div class="line"></div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line"></div><div class="line">    lazy var asHTML: Void -&gt; String = &#123;</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125; else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name) is being deinitialized&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">asHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。</div><div class="line">也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属</div><div class="line">性。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。</div></pre></td></tr></table></figure>
<h3 id="解决闭包引起的循环强引用"><a href="#解决闭包引起的循环强引用" class="headerlink" title="解决闭包引起的循环强引用"></a>解决闭包引起的循环强引用</h3><p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者</div><div class="line">self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了</div><div class="line">self。</div></pre></td></tr></table></figure>
<h3 id="定义捕获列表"><a href="#定义捕获列表" class="headerlink" title="定义捕获列表"></a>定义捕获列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lazy var someClosure: (Int, String) -&gt; String = &#123;</div><div class="line">    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in</div><div class="line">    // 这里是闭包的函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lazy var someClosure: Void -&gt; String = &#123;</div><div class="line">    [unowned self, weak delegate = self.delegate!] in</div><div class="line">    // 这里是闭包的函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。</div></pre></td></tr></table></figure>
<h2 id="可选链式调用"><a href="#可选链式调用" class="headerlink" title="可选链式调用"></a>可选链式调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">Swift 的可选链式调用和 Objective-C 中向nil发送消息有些相像，但是 Swift 的可选链式调用可以应</div><div class="line">用于任意类型，并且能检查调用是否成功。</div></pre></td></tr></table></figure>
<h3 id="使用可选链式调用代替强制展开"><a href="#使用可选链式调用代替强制展开" class="headerlink" title="使用可选链式调用代替强制展开"></a>使用可选链式调用代替强制展开</h3><p>通过在想调用的属性、方法、或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let roomCount = john.residence!.numberOfRooms</div><div class="line">// 这会引发运行时错误</div><div class="line"></div><div class="line">if let roomCount = john.residence?.numberOfRooms &#123;</div><div class="line">    print(&quot;John&apos;s residence has \(roomCount) room(s).&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;Unable to retrieve the number of rooms.&quot;)</div><div class="line">&#125;</div><div class="line">// 打印 “Unable to retrieve the number of rooms.”</div></pre></td></tr></table></figure>
<h3 id="通过可选链式调用访问下标"><a href="#通过可选链式调用访问下标" class="headerlink" title="通过可选链式调用访问下标"></a>通过可选链式调用访问下标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号</div><div class="line">一般直接跟在可选表达式的后面。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">john.residence?[0] = Room(name: &quot;Bathroom&quot;)</div></pre></td></tr></table></figure>
<h3 id="访问可选类型的下标"><a href="#访问可选类型的下标" class="headerlink" title="访问可选类型的下标"></a>访问可选类型的下标</h3><p>如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]</div><div class="line">testScores[&quot;Dave&quot;]?[0] = 91</div><div class="line">testScores[&quot;Bev&quot;]?[0] += 1</div><div class="line">testScores[&quot;Brian&quot;]?[0] = 72</div><div class="line">// &quot;Dave&quot; 数组现在是 [91, 82, 84]，&quot;Bev&quot; 数组现在是 [80, 94, 81]</div></pre></td></tr></table></figure>
<h3 id="连接多层可选链式调用"><a href="#连接多层可选链式调用" class="headerlink" title="连接多层可选链式调用"></a>连接多层可选链式调用</h3><p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>
<p>也就是说：</p>
<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>
<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>
</ul>
<p>因此：</p>
<ul>
<li>通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。</li>
<li>类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。</li>
</ul>
<h3 id="在方法的可选返回值上进行可选链式调用"><a href="#在方法的可选返回值上进行可选链式调用" class="headerlink" title="在方法的可选返回值上进行可选链式调用"></a>在方法的可选返回值上进行可选链式调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if let beginsWithThe =</div><div class="line">    john.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;The&quot;) &#123;</div><div class="line">        if beginsWithThe &#123;</div><div class="line">            print(&quot;John&apos;s building identifier begins with \&quot;The\&quot;.&quot;)</div><div class="line">        &#125; else &#123;</div><div class="line">            print(&quot;John&apos;s building identifier does not begin with \&quot;The\&quot;.&quot;)</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">在上面的例子中，在方法的圆括号后面加上问号是因为你要在buildingIdentifier()方法的可选返回值上</div><div class="line">进行可选链式调用，而不是方法本身。</div></pre></td></tr></table></figure>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum VendingMachineError: Error &#123;</div><div class="line">    case invalidSelection                    //选择无效</div><div class="line">    case insufficientFunds(coinsNeeded: Int) //金额不足</div><div class="line">    case outOfStock                          //缺货</div><div class="line">&#125;</div><div class="line"></div><div class="line">throw VendingMachineError. insufficientFunds(coinsNeeded: 5)</div></pre></td></tr></table></figure>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>swift 中有4种处理错误的方式。</p>
<ul>
<li>函数抛出错误</li>
<li>do - catch</li>
<li>将错误进行可选处理</li>
<li>或者用断言避免此种错误</li>
</ul>
<p>在调用一个能抛出错误的函数、方法或者构造器之前，加上try关键字，或者try?或try!这种变体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">Swift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 </div><div class="line">Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂</div><div class="line">的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。</div><div class="line">```  </div><div class="line"></div><div class="line">### 用 throwing 函数传递错误</div><div class="line">为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有throws关键字的函数被称作throwing 函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（-&gt;）的前面。</div></pre></td></tr></table></figure>
<p>func canThrowErrors() throws -&gt; String<br>func cannotThrowErrors() -&gt; String<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 用Do - Catch处理错误</div></pre></td></tr></table></figure></p>
<p>do {<br>    try expression<br>    statements<br>} catch pattern 1 {<br>    statements<br>} catch pattern 2 where condition {<br>    statements<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 将错误转换成可选值</div><div class="line">可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。</div></pre></td></tr></table></figure></p>
<p>func someThrowingFunction() throws -&gt; Int {<br>    // …<br>}</p>
<p>let x = try? someThrowingFunction()</p>
<p>let y: Int?<br>do {<br>    y = try someThrowingFunction()<br>} catch {<br>    y = nil<br>}</p>
<p>func fetchData() -&gt; Data? {<br>    if let data = try? fetchDataFromDisk() { return data }<br>    if let data = try? fetchDataFromServer() { return data }<br>    return nil<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 禁用错误传递</div><div class="line">有时你知道某个throwing函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写try!来禁用错误传递，这会把调用包装在一个不会有错误抛出的运行时断言中。如果真的抛出了错误，你会得到一个运行时错误。</div></pre></td></tr></table></figure></p>
<p>let photo = try! loadImage(atPath: “./Resources/John Appleseed.jpg”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### defer</div><div class="line">可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句。</div><div class="line"></div><div class="line">defer语句将代码的执行延迟到当前的作用域退出之前。</div></pre></td></tr></table></figure></p>
<p>func processFile(filename: String) throws {<br>    if exists(filename) {<br>        let file = open(filename)<br>        defer {<br>            close(file)<br>        }<br>        while let line = try file.readline() {<br>            // 处理文件。<br>        }<br>        // close(file) 会在这里被调用，即作用域的最后。<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>即使没有涉及到错误处理，你也可以使用defer语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 类型转换</div><div class="line">### as? 和 as!</div><div class="line">某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。</div><div class="line"></div><div class="line">因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型和强制解包（转换结果结合为一个操作。</div><div class="line"></div><div class="line">当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。</div></pre></td></tr></table></figure></p>
<p>注意<br>转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Any 和 AnyObject 的类型转换</div><div class="line">Swift 为不确定类型提供了两种特殊的类型别名：</div><div class="line"></div><div class="line">- Any 可以表示任何类型，包括函数类型。</div><div class="line">- AnyObject 可以表示任何类类型的实例。</div></pre></td></tr></table></figure></p>
<p>注意<br>Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一<br>个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显式转换为Any，如下所示：</p>
<p>let optionalNumber: Int? = 3<br>things.append(optionalNumber)        // 警告<br>things.append(optionalNumber as Any) // 没有警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 嵌套类型</div><div class="line">### 嵌套类型实践</div></pre></td></tr></table></figure></p>
<p>struct BlackjackCard {<br>    // 嵌套的 Suit 枚举<br>    enum Suit: Character {<br>       case Spades = “♠”, Hearts = “♡”, Diamonds = “♢”, Clubs = “♣”<br>    }</p>
<pre><code>// 嵌套的 Rank 枚举
enum Rank: Int {
   case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
   case Jack, Queen, King, Ace
   struct Values {
       let first: Int, second: Int?
   }
   var values: Values {
    switch self {
    case .Ace:
        return Values(first: 1, second: 11)
    case .Jack, .Queen, .King:
        return Values(first: 10, second: nil)
    default:
        return Values(first: self.rawValue, second: nil)
        }
   }
}

// BlackjackCard 的属性和方法
let rank: Rank, suit: Suit
var description: String {
    var output = &quot;suit is \(suit.rawValue),&quot;
    output += &quot; value is \(rank.values.first)&quot;
    if let second = rank.values.second {
        output += &quot; or \(second)&quot;
    }
    return output
}
</code></pre><p>}</p>
<p>let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue<br>// 红心符号为 “♡”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 扩展</div><div class="line">### 扩展语法</div></pre></td></tr></table></figure></p>
<p>extension SomeType {<br>    // 为 SomeType 添加的新功能写到这里<br>}</p>
<p>extension SomeType: SomeProtocol, AnotherProctocol {<br>    // 协议实现写到这里<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在<br>这个扩展定义之前创建的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 计算型属性</div><div class="line">扩展可以为已有类型添加计算型实例属性和计算型类型属性。</div></pre></td></tr></table></figure></p>
<p>extension Double {<br>    var km: Double { return self * 1_000.0 }<br>    var m : Double { return self }<br>    var cm: Double { return self / 100.0 }<br>    var mm: Double { return self / 1_000.0 }<br>    var ft: Double { return self / 3.28084 }<br>}<br>let oneInch = 25.4.mm<br>print(“One inch is (oneInch) meters”)<br>// 打印 “One inch is 0.0254 meters”<br>let threeFeet = 3.ft<br>print(“Three feet is (threeFeet) meters”)<br>// 打印 “Three feet is 0.914399970739201 meters”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 构造器</div></pre></td></tr></table></figure></p>
<p>注意<br>如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属<br>性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。<br>正如在值类型的构造器代理中描述的，如果你把定制的构造器写在值类型的原始实现中，上述规则将不再适<br>用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 方法</div></pre></td></tr></table></figure></p>
<p>extension Int {<br>    func repetitions(task: () -&gt; Void) {<br>        for _ in 0..&lt;self {<br>            task()<br>        }<br>    }<br>}</p>
<p>//可变实例方法<br>extension Int {<br>    mutating func square() {<br>        self = self * self<br>    }<br>}</p>
<p>//下标<br>extension Int {<br>    subscript(digitIndex: Int) -&gt; Int {<br>        var decimalBase = 1<br>        for _ in 0..<digitindex 2="" 5="" 7="" 9="" 10="" {="" decimalbase="" *="10" }="" return="" (self="" decimalbase)="" %="" 746381295[0]="" 返回="" 746381295[1]="" 746381295[2]="" 746381295[8]="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 嵌套类</div></pre></td></tr></table></digitindex></p>
<p>extension Int {<br>    enum Kind {<br>        case Negative, Zero, Positive<br>    }<br>    var kind: Kind {<br>        switch self {<br>        case 0:<br>            return .Zero<br>        case let x where x &gt; 0:<br>            return .Positive<br>        default:<br>            return .Negative<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可<br>以使用简写形式，例如使用 . Negative 而不是 Int.Kind.Negative。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 协议</div><div class="line">### 协议语法</div></pre></td></tr></table></figure></p>
<p>protocol SomeProtocol {<br>    // 这里是协议的定义部分<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 属性要求</div><div class="line">协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。</div></pre></td></tr></table></figure></p>
<p>protocol SomeProtocol {<br>    var mustBeSettable: Int { get set }<br>    var doesNotNeedToBeSettable: Int { get }<br>    static var someTypeProperty: Int { get set }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 方法要求</div><div class="line">协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。</div></pre></td></tr></table></figure></p>
<p>protocol SomeProtocol {<br>    static func someTypeMethod()<br>    func random() -&gt; Double<br>    //mutaing方法<br>    mutating func toggle()<br>    //构造器方法<br>    init(someParameter: Int)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必<br>须写 mutating 关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。关于 final 修饰符的更多内容，请参见防止重写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 构造器要求在类中的实现</div></pre></td></tr></table></figure></p>
<p>class SomeClass: SomeProtocol {<br>    required init(someParameter: Int) {<br>        // 这里是构造器的实现部分<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类<br>不能有子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时</div><div class="line">标注 required 和 override修饰符</div></pre></td></tr></table></figure></p>
<p>protocol SomeProtocol {<br>    init()<br>}</p>
<p>class SomeSuperClass {<br>    init() {<br>        // 这里是构造器的实现部分<br>    }<br>}</p>
<p>class SomeSubClass: SomeSuperClass, SomeProtocol {<br>    // 因为遵循协议，需要加上 required<br>    // 因为继承自父类，需要加上 override<br>    required override init() {<br>        // 这里是构造器的实现部分<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 可失败构造器要求</div><div class="line">遵循协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。</div><div class="line"></div><div class="line">### 协议作为类型</div><div class="line">协议可以像其他普通类型一样使用，使用场景如下：</div><div class="line"></div><div class="line">- 作为函数、方法或构造器中的参数类型或返回值类型</div><div class="line">- 作为常量、变量或属性的类型</div><div class="line">- 作为数组、字典或其他容器中的元素类型</div></pre></td></tr></table></figure></p>
<p>注意<br>协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大<br>写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 通过扩展添加协议一致性</div></pre></td></tr></table></figure></p>
<p>注意<br>通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 类类型专属协议</div><div class="line">你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。</div></pre></td></tr></table></figure></p>
<p>protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {<br>    // 这里是类类型专属协议的定义部分<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 协议合成</div><div class="line">有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。</div></pre></td></tr></table></figure></p>
<p>func wishHappyBirthday(to celebrator: Named &amp; Aged) {<br>    print(“Happy birthday, (celebrator.name), you’re (celebrator.age)!”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 检查协议一致性</div><div class="line"></div><div class="line">- is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。</div><div class="line">- as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。</div><div class="line">- as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</div><div class="line"></div><div class="line">### 可选的协议要求</div><div class="line">在协议中使用 optional 关键字作为前缀来定义可选要求。</div><div class="line">可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性。</div></pre></td></tr></table></figure></p>
<p>@objc protocol CounterDataSource {<br>    @objc optional func incrementForCount(count: Int) -&gt; Int<br>    @objc optional var fixedIncrement: Int { get }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要<br>求，尽管技术上允许这样做，不过最好不要这样写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 协议扩展</div><div class="line">协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</div></pre></td></tr></table></figure></p>
<p>extension RandomNumberGenerator {<br>    func randomBool() -&gt; Bool {<br>        return random() &gt; 0.5<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 为协议扩展添加限制条件</div><div class="line">在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述，正如Where子句中所描述的。</div><div class="line"></div><div class="line">例如，你可以扩展 CollectionType 协议，但是只适用于集合中的元素遵循了 TextRepresentable 协议的情况：</div></pre></td></tr></table></figure></p>
<p>extension Collection where Iterator.Element: TextRepresentable {<br>    var textualDescription: String {<br>        let itemsAsText = self.map { $0.textualDescription }<br>        return “[“ + itemsAsText.joined(separator: “, “) + “]”<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条<br>件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 泛型</div></pre></td></tr></table></figure></p>
<p>func swapTwoInts(<em> a: inout Int, </em> b: inout Int) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>在上面三个函数中，a 和 b 类型相同。如果 a 和 b 类型不同，那它们俩就不能互换值。Swift 是类型安<br>全的语言，所以它不允许一个 String 类型的变量和一个 Double 类型的变量互换值。试图这样做将导致<br>编译错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 泛型语法</div></pre></td></tr></table></figure></p>
<p>func swapTwoValues<t>(<em> a: inout T, </em> b: inout T) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}</t></p>
<p>var someInt = 3<br>var anotherInt = 107<br>swapTwoValues(&amp;someInt, &amp;anotherInt)<br>// someInt 现在 107, and anotherInt 现在 3</p>
<p>var someString = “hello”<br>var anotherString = “world”<br>swapTwoValues(&amp;someString, &amp;anotherString)<br>// someString 现在 “world”, and anotherString 现在 “hello”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是<br>占位类型，而不是一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 泛型类型</div></pre></td></tr></table></figure></p>
<p>struct Stack<element> {<br>    var items = <a href="">Element</a><br>    mutating func push(_ item: Element) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Element {<br>        return items.removeLast()<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 扩展一个泛型类型</div><div class="line">当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。</div></pre></td></tr></table></figure></element></p>
<p>extension Stack {<br>    var topItem: Element? {<br>        return items.isEmpty ? nil : items[items.count - 1]<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 类型约束语法</div></pre></td></tr></table></figure></p>
<p>func someFunction<t: someclass,="" u:="" someprotocol="">(someT: T, someU: U) {<br>    // 这里是泛型函数的函数体部分<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 T，当你试图编译这部分代码时会出现相应的错误。</div><div class="line"></div><div class="line">Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。</div><div class="line"></div><div class="line">任何 Equatable 类型都可以安全地使用在 findIndex(of:in:) 函数中，因为其保证支持等式操作符。</div></pre></td></tr></table></figure></t:></p>
<p>func findIndex<t: equatable="">(of valueToFind: T, in array:[T]) -&gt; Int? {<br>    for (index, value) in array.enumerated() {<br>        if value == valueToFind {<br>            return index<br>        }<br>    }<br>    return nil<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 关联类型</div><div class="line">定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。</div></pre></td></tr></table></figure></t:></p>
<p>protocol Container {<br>    associatedtype ItemType<br>    mutating func append(_ item: ItemType)<br>    var count: Int { get }<br>    subscript(i: Int) -&gt; ItemType { get }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 通过扩展一个存在的类型来指定关联类型</div></pre></td></tr></table></figure></p>
<p>extension Array: Container {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 泛型 Where 语句</div><div class="line">你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。</div></pre></td></tr></table></figure></p>
<p>func allItemsMatch<c1: container,="" c2:="" container=""><br>    (<em> someContainer: C1, </em> anotherContainer: C2) -&gt; Bool<br>    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {</c1:></p>
<pre><code>// 检查两个容器含有相同数量的元素
if someContainer.count != anotherContainer.count {
    return false
}

// 检查每一对元素是否相等
for i in 0..&lt;someContainer.count {
    if someContainer[i] != anotherContainer[i] {
        return false
    }
}

// 所有元素都匹配，返回 true
return true
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 具有泛型 where 子句的扩展</div></pre></td></tr></table></figure></p>
<p>extension Stack where Element: Equatable {<br>    func isTop(_ item: Element) -&gt; Bool {<br>        guard let topItem = items.last else {<br>            return false<br>        }<br>        return topItem == item<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 访问控制</div><div class="line">### 模块和源文件</div><div class="line">模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。</div><div class="line"></div><div class="line">### 访问级别</div><div class="line">- `open`和`public`可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。</div><div class="line">- `internal`可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。</div><div class="line">- `fileprivate`访只能被所定义的文件内部访问。</div><div class="line">- `private`只能在所定义的作用域内使用。</div><div class="line"></div><div class="line">`open`为最高访问级别，`private`为最低访问级别。  </div><div class="line"></div><div class="line">`open` &gt; `public` &gt; `internal` &gt; `fileprivate` &gt;  `private`  </div><div class="line"></div><div class="line">`open`只作用于类类型和类的成员，它和`public`的区别如下：</div><div class="line"></div><div class="line">- &gt; `public` 的类，只能在它们定义的模块内部被继承。</div><div class="line">- &gt; `public` 的类成员，只能在它们定义的模块内部的子类中重写。</div><div class="line">- `open`的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。</div><div class="line">- `open`的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。</div><div class="line">- 把一个类标记为`open`，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。</div><div class="line"></div><div class="line">### 访问级别基本原则</div><div class="line">- `public`的变量，其类型的访问级别不能是`internal`，`fileprivate`或是`private`的。因为无法保证变量的类型在使用变量的地方也具有访问权限。</div><div class="line">- 函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。</div><div class="line"></div><div class="line">### 默认访问级别</div><div class="line">默认为 `internal` 级别。</div><div class="line"></div><div class="line">### 框架的访问级别</div><div class="line">当你开发框架时，就需要把一些对外的接口定义为开放访问或公开访问级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为对外的接口，就是这个框架的 API。</div></pre></td></tr></table></figure></p>
<p>注意<br>框架依然会使用默认的<code>internal</code>级别，也可以指定为<code>fileprivate</code>或者<code>private</code>级别。当你想把某个实体作为<br>框架的 API 的时候，需显式为其指定<code>open</code>或<code>public</code>级别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 自定义类型</div><div class="line">如果你将类型指定为`fileprivate`或者`private`级别，那么该类的成员的默认级别也会变成`fileprivate`或者`private`级别。如果你将类指定为`public`或者`internal`，那么该类所有成员的默认级别将是`internal`。</div><div class="line"></div><div class="line"></div><div class="line">### 元组类型</div><div class="line">元组的访问级别将由元组中访问级别最严格的类型来决定</div></pre></td></tr></table></figure></p>
<p>注意<br>元组的访问级别是在它被使用时自动推断出的，而无法明确指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 函数类型</div><div class="line">函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。</div><div class="line"></div><div class="line">### 枚举类型</div><div class="line">枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。</div><div class="line">枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。</div><div class="line"></div><div class="line">### 嵌套类型</div><div class="line">如果在 `private` 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 `private` 访问级别。如果在 `public` 或者 `internal` 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 `internal` 访问级别。如果想让嵌套类型拥有 `public` 访问级别，那么需要明确指定该嵌套类型的访问级别。</div><div class="line"></div><div class="line">### 子类</div><div class="line">子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 `internal`，子类的访问级别就不能是 `public`。</div><div class="line"></div><div class="line">### 常量、变量、属性、下标</div><div class="line">常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 `public` 级别的属性，但是它的类型却是 `private` 级别的。</div><div class="line"></div><div class="line">### Getter 和 Setter</div><div class="line">常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。</div></pre></td></tr></table></figure></p>
<p>注意<br>这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter，<br>Swift 也会隐式地为其创建 Getter 和 Setter，用于访问该属性的后备存储。使用<br>fileprivate(set)，private(set) 和 internal(set) 可以改变 Setter 的访问级别，这对计算型<br>属性也同样适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 构造器</div><div class="line">自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是必要构造器，它的访问级别必须和所属类型的访问级别相同。</div><div class="line"></div><div class="line">如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</div><div class="line"></div><div class="line">### 默认构造器</div><div class="line">如默认构造器所述，Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。</div><div class="line"></div><div class="line">默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 public。如果一个类型被指定为 public 级别，那么默认构造器的访问级别将为 internal。如果你希望一个 public 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 public 访问级别的无参数构造器。</div><div class="line"></div><div class="line">### 结构体默认的成员逐一构造器</div><div class="line">如果结构体中任意存储型属性的访问级别为 private，那么该结构体默认的成员逐一构造器的访问级别就是 private。否则，这种构造器的访问级别依然是 internal。</div><div class="line"></div><div class="line">如同前面提到的默认构造器，如果你希望一个 public 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 public 访问级别的成员逐一构造器。</div><div class="line"></div><div class="line">### 协议</div><div class="line">协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。</div></pre></td></tr></table></figure></p>
<p>注意<br>如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不<br>同于其他类型，例如，当类型是 public 访问级别时，其成员的访问级别却只是 internal。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 协议继承</div><div class="line">如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 `internal` 协议的新协议定义为 `public` 协议。</div><div class="line"></div><div class="line">### 协议一致性</div><div class="line">一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。</div><div class="line"></div><div class="line">采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 public 级别，采纳的协议是 internal 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 internal。</div><div class="line"></div><div class="line">如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 public 级别的类型，采纳了 internal 级别的协议，那么协议的实现至少也得是 internal 级别。</div></pre></td></tr></table></figure></p>
<p>注意<br>Swift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种<br>不同的方式实现同一个协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 扩展</div><div class="line">你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 public 或者 internal 类型，扩展中的成员具有默认的 internal 访问级别，和原始类型中的成员一致 。如果你扩展了一个 private 类型，扩展成员则拥有默认的 private 访问级别。</div><div class="line"></div><div class="line">或者，你可以明确指定扩展的访问级别（例如，private extension），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。</div><div class="line"></div><div class="line">### 通过扩展添加协议一致性</div><div class="line"></div><div class="line">如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</div><div class="line"></div><div class="line">### 泛型</div><div class="line">泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</div><div class="line"></div><div class="line">### 类型别名</div><div class="line">你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，private 级别的类型别名可以作为 `private`，`file-private`，`internal`，`public`或者`open`类型的别名，但是 `public` 级别的类型别名只能作为 `public` 类型的别名，不能作为 `internal`，`file-private`，或 `private` 类型的别名。</div></pre></td></tr></table></figure></p>
<p>注意<br>这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 高级运算符</div><div class="line">### 取反`~`</div></pre></td></tr></table></figure></p>
<p>let initialBits: UInt8 = 0b00001111<br>let invertedBits = ~initialBits // 等于 0b11110000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 与运算`&amp;`</div></pre></td></tr></table></figure></p>
<p>let firstSixBits: UInt8 = 0b11111100<br>let lastSixBits: UInt8  = 0b00111111<br>let middleFourBits = firstSixBits &amp; lastSixBits // 等于 00111100<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 或运算`|`</div></pre></td></tr></table></figure></p>
<p>let someBits: UInt8 = 0b10110010<br>let moreBits: UInt8 = 0b01011110<br>let combinedbits = someBits | moreBits // 等于 11111110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 异或运算`^`</div></pre></td></tr></table></figure></p>
<p>let firstBits: UInt8 = 0b00010100<br>let otherBits: UInt8 = 0b00000101<br>let outputBits = firstBits ^ otherBits // 等于 00010001<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 左移`&lt;&lt;`和右移`&gt;&gt;`</div><div class="line">对无符号整数进行移位的规则如下：</div><div class="line"></div><div class="line">- 已经存在的位按指定的位数进行左移和右移。</div><div class="line">- 任何因移动而超出整型存储范围的位都会被丢弃。</div><div class="line">- 用 0 来填充移位后产生的空白位。</div></pre></td></tr></table></figure></p>
<p>let shiftBits: UInt8 = 4 // 即二进制的 00000100<br>shiftBits &lt;&lt; 1           // 00001000<br>shiftBits &lt;&lt; 2           // 00010000<br>shiftBits &lt;&lt; 5           // 10000000<br>shiftBits &lt;&lt; 6           // 00000000<br>shiftBits &gt;&gt; 2           // 00000001<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 溢出运算符</div><div class="line">在默认情况下，当向一个整数赋予超过它容量的值时，Swift 默认会报错，而不是生成一个无效的数。这个行为为我们在运算过大或着过小的数的时候提供了额外的安全性。</div><div class="line"></div><div class="line">然而，也可以选择让系统在数值溢出的时候采取截断处理，而非报错。</div><div class="line"></div><div class="line">- 溢出加法 `&amp;+`</div><div class="line">- 溢出减法 `&amp;-`</div><div class="line">- 溢出乘法 `&amp;*`</div><div class="line"></div><div class="line">### 数值溢出</div></pre></td></tr></table></figure></p>
<p>var unsignedOverflow = UInt8.max<br>// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255<br>unsignedOverflow = unsignedOverflow &amp;+ 1<br>// 此时 unsignedOverflow 等于 0</p>
<p>var unsignedOverflow = UInt8.min<br>// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0<br>unsignedOverflow = unsignedOverflow &amp;- 1<br>// 此时 unsignedOverflow 等于 255<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 优先级和结合性</div></pre></td></tr></table></figure></p>
<p>注意<br>相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也<br>意味着它们相较于 C 语言及其衍生语言并不是完全一致的。在对现有的代码进行移植的时候，要注意确保运<br>算符的行为仍然符合你的预期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 运算符重载</div></pre></td></tr></table></figure></p>
<p>struct Vector2D {<br>    var x = 0.0, y = 0.0<br>}</p>
<p>extension Vector2D {<br>    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: left.x + right.x, y: left.y + right.y)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 前缀和后缀运算符</div><div class="line">当运算符出现在值之前时，它就是前缀的（例如 -a），而当它出现在值之后时，它就是后缀的（例如 b!）。</div><div class="line"></div><div class="line">要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 修饰符：</div></pre></td></tr></table></figure></p>
<p>extension Vector2D {<br>    static prefix func - (vector: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: -vector.x, y: -vector.y)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 复合赋值运算符</div></pre></td></tr></table></figure></p>
<p>extension Vector2D {<br>    static func += (left: inout Vector2D, right: Vector2D) {<br>        left = left + right<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>注意<br>不能对默认的赋值运算符（=）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算<br>符 （a ? b : c） 进行重载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 等价运算符</div></pre></td></tr></table></figure></p>
<p>extension Vector2D {<br>    static func == (left: Vector2D, right: Vector2D) -&gt; Bool {<br>        return (left.x == right.x) &amp;&amp; (left.y == right.y)<br>    }<br>    static func != (left: Vector2D, right: Vector2D) -&gt; Bool {<br>        return !(left == right)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 自定义运算符</div><div class="line">新的运算符要使用 operator 关键字在全局作用域内进行定义，同时还要指定 prefix、infix 或者 postfix 修饰符：</div><div class="line"></div><div class="line">`prefix operator +++`</div></pre></td></tr></table></figure></p>
<p>extension Vector2D {<br>    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {<br>        vector += vector<br>        return vector<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 自定义中缀运算符的优先级</div><div class="line">每个自定义中缀运算符都属于某个优先级组。  </div><div class="line">而没有明确放入优先级组的自定义中缀运算符会放到一个默认的优先级组内，其优先级高于三元运算符。</div><div class="line"></div><div class="line">此运算符属于 `AdditionPrecedence` 优先组：</div></pre></td></tr></table></figure></p>
<p>infix operator +-: AdditionPrecedence<br>extension Vector2D {<br>    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: left.x + right.x, y: left.y - right.y)<br>    }<br>}<br>let firstVector = Vector2D(x: 1.0, y: 2.0)<br>let secondVector = Vector2D(x: 3.0, y: 4.0)<br>let plusMinusVector = firstVector +- secondVector<br>// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure></p>
<p>注意<br>当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算<br>符，则后缀运算符会先参与运算。<br>```</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/转载/" rel="tag"># 转载</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/19/SQLmap学习笔记/" rel="next" title="SQLmap学习笔记">
                <i class="fa fa-chevron-left"></i> SQLmap学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/27/Shell简单教程/" rel="prev" title="Shell简单教程">
                Shell简单教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/user.png"
               alt="zgjx" />
          <p class="site-author-name" itemprop="name">zgjx</p>
           
              <p class="site-description motion-element" itemprop="description">My blog</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zgjx6" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/780c677673ef" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                  Jianshu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础部分"><span class="nav-number">1.</span> <span class="nav-text">基础部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整数的进制"><span class="nav-number">1.1.</span> <span class="nav-text">整数的进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和"><span class="nav-number">1.2.</span> <span class="nav-text">?和!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元组"><span class="nav-number">1.3.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理"><span class="nav-number">1.4.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断言"><span class="nav-number">1.5.</span> <span class="nav-text">断言</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">2.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gt-和-lt"><span class="nav-number">2.1.</span> <span class="nav-text">>= 和 <=</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元组的比较"><span class="nav-number">2.2.</span> <span class="nav-text">元组的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空合运算符"><span class="nav-number">2.3.</span> <span class="nav-text">空合运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间运算符"><span class="nav-number">2.4.</span> <span class="nav-text">区间运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符与字符串"><span class="nav-number">3.</span> <span class="nav-text">字符与字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串常量"><span class="nav-number">3.1.</span> <span class="nav-text">字符串常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串支持-和-操作"><span class="nav-number">3.2.</span> <span class="nav-text">字符串支持+和+=操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串是值类型"><span class="nav-number">3.3.</span> <span class="nav-text">字符串是值类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用字符"><span class="nav-number">3.4.</span> <span class="nav-text">使用字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串插值"><span class="nav-number">3.5.</span> <span class="nav-text">字符串插值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode标量"><span class="nav-number">3.6.</span> <span class="nav-text">Unicode标量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算字符数量"><span class="nav-number">3.7.</span> <span class="nav-text">计算字符数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串比较"><span class="nav-number">3.8.</span> <span class="nav-text">字符串比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UTF-8表示"><span class="nav-number">3.9.</span> <span class="nav-text">UTF-8表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UTF-16表示"><span class="nav-number">3.10.</span> <span class="nav-text">UTF-16表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode-标量表示"><span class="nav-number">3.11.</span> <span class="nav-text">Unicode 标量表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架"><span class="nav-number">4.</span> <span class="nav-text">集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三种集合类型"><span class="nav-number">4.1.</span> <span class="nav-text">三种集合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合可变性"><span class="nav-number">4.2.</span> <span class="nav-text">集合可变性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个空数组"><span class="nav-number">4.3.</span> <span class="nav-text">创建一个空数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个带有默认值的数组"><span class="nav-number">4.4.</span> <span class="nav-text">创建一个带有默认值的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组支持-和-运算符"><span class="nav-number">4.5.</span> <span class="nav-text">数组支持+和+=运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断数组为空"><span class="nav-number">4.6.</span> <span class="nav-text">判断数组为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以用区间批量改变数组的值"><span class="nav-number">4.7.</span> <span class="nav-text">可以用区间批量改变数组的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用enumerated遍历数组"><span class="nav-number">4.8.</span> <span class="nav-text">用enumerated遍历数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建和构造一个空的集合"><span class="nav-number">4.9.</span> <span class="nav-text">创建和构造一个空的集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以用数组字面量创建一个集合"><span class="nav-number">4.10.</span> <span class="nav-text">可以用数组字面量创建一个集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合操作"><span class="nav-number">4.11.</span> <span class="nav-text">集合操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个空字典"><span class="nav-number">4.12.</span> <span class="nav-text">创建一个空字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典字面量"><span class="nav-number">4.13.</span> <span class="nav-text">字典字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典遍历"><span class="nav-number">4.14.</span> <span class="nav-text">字典遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制流"><span class="nav-number">5.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用匿名变量遍历"><span class="nav-number">5.1.</span> <span class="nav-text">使用匿名变量遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Repeat-While循环"><span class="nav-number">5.2.</span> <span class="nav-text">Repeat-While循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持区间和组合的Switch"><span class="nav-number">5.3.</span> <span class="nav-text">支持区间和组合的Switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Switch中的元组"><span class="nav-number">5.4.</span> <span class="nav-text">Switch中的元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Switch值绑定与where"><span class="nav-number">5.5.</span> <span class="nav-text">Switch值绑定与where</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Switch-For-Continue"><span class="nav-number">5.6.</span> <span class="nav-text">Switch,For,Continue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Switch贯穿"><span class="nav-number">5.7.</span> <span class="nav-text">Switch贯穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Continue-Break的标签"><span class="nav-number">5.8.</span> <span class="nav-text">Continue,Break的标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#guard"><span class="nav-number">5.9.</span> <span class="nav-text">guard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#available"><span class="nav-number">5.10.</span> <span class="nav-text">#available</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数定义"><span class="nav-number">6.1.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选元组返回类型"><span class="nav-number">6.2.</span> <span class="nav-text">可选元组返回类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定参数标签"><span class="nav-number">6.3.</span> <span class="nav-text">指定参数标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#忽略参数标签"><span class="nav-number">6.4.</span> <span class="nav-text">忽略参数标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式参数值"><span class="nav-number">6.5.</span> <span class="nav-text">模式参数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数"><span class="nav-number">6.6.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入输出参数"><span class="nav-number">6.7.</span> <span class="nav-text">输入输出参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用函数类型"><span class="nav-number">6.8.</span> <span class="nav-text">使用函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套函数"><span class="nav-number">6.9.</span> <span class="nav-text">嵌套函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">7.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包表达式语法"><span class="nav-number">7.1.</span> <span class="nav-text">闭包表达式语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据上下文推断类型"><span class="nav-number">7.2.</span> <span class="nav-text">根据上下文推断类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单表达式闭包隐式返回"><span class="nav-number">7.3.</span> <span class="nav-text">单表达式闭包隐式返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数名称缩写"><span class="nav-number">7.4.</span> <span class="nav-text">参数名称缩写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符方法"><span class="nav-number">7.5.</span> <span class="nav-text">运算符方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尾随闭包"><span class="nav-number">7.6.</span> <span class="nav-text">尾随闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包逃逸"><span class="nav-number">7.7.</span> <span class="nav-text">闭包逃逸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动闭包"><span class="nav-number">7.8.</span> <span class="nav-text">自动闭包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">8.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举语法"><span class="nav-number">8.1.</span> <span class="nav-text">枚举语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Switch-语句匹配枚举值"><span class="nav-number">8.2.</span> <span class="nav-text">使用 Switch 语句匹配枚举值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联值"><span class="nav-number">8.3.</span> <span class="nav-text">关联值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原始值"><span class="nav-number">8.4.</span> <span class="nav-text">原始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原始值的隐式赋值"><span class="nav-number">8.5.</span> <span class="nav-text">原始值的隐式赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用原始值初始化枚举实例"><span class="nav-number">8.6.</span> <span class="nav-text">使用原始值初始化枚举实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归枚举"><span class="nav-number">8.7.</span> <span class="nav-text">递归枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">9.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类和结构体对比"><span class="nav-number">9.1.</span> <span class="nav-text">类和结构体对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义语法"><span class="nav-number">9.2.</span> <span class="nav-text">定义语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">9.3.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体类型的成员逐一构造器"><span class="nav-number">9.4.</span> <span class="nav-text">结构体类型的成员逐一构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体和枚举是值类型-类是引用类型"><span class="nav-number">9.5.</span> <span class="nav-text">结构体和枚举是值类型,类是引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#恒等运算符"><span class="nav-number">9.6.</span> <span class="nav-text">恒等运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类和结构体的选择"><span class="nav-number">9.7.</span> <span class="nav-text">类和结构体的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串、数组、和字典类型的赋值与复制行为"><span class="nav-number">9.8.</span> <span class="nav-text">字符串、数组、和字典类型的赋值与复制行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性-1"><span class="nav-number">9.9.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟存储属性"><span class="nav-number">9.10.</span> <span class="nav-text">延迟存储属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算属性"><span class="nav-number">9.11.</span> <span class="nav-text">计算属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简化Setter"><span class="nav-number">9.12.</span> <span class="nav-text">简化Setter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只读计算属性"><span class="nav-number">9.13.</span> <span class="nav-text">只读计算属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性观察器"><span class="nav-number">9.14.</span> <span class="nav-text">属性观察器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局变量和局部变量"><span class="nav-number">9.15.</span> <span class="nav-text">全局变量和局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类属性"><span class="nav-number">9.16.</span> <span class="nav-text">类属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型属性语法"><span class="nav-number">9.17.</span> <span class="nav-text">类型属性语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">10.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在实例方法中修改值类型"><span class="nav-number">10.1.</span> <span class="nav-text">在实例方法中修改值类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类方法"><span class="nav-number">10.2.</span> <span class="nav-text">类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下标"><span class="nav-number">11.</span> <span class="nav-text">下标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义下标属性"><span class="nav-number">11.1.</span> <span class="nav-text">定义下标属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下标选项"><span class="nav-number">11.2.</span> <span class="nav-text">下标选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">12.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承语法"><span class="nav-number">12.1.</span> <span class="nav-text">继承语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写"><span class="nav-number">12.2.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">12.3.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写属性"><span class="nav-number">12.4.</span> <span class="nav-text">重写属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防止重写"><span class="nav-number">12.5.</span> <span class="nav-text">防止重写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造过程"><span class="nav-number">13.</span> <span class="nav-text">构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储属性的初始赋值"><span class="nav-number">13.1.</span> <span class="nav-text">存储属性的初始赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器"><span class="nav-number">13.2.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数的内部名称和外部名称"><span class="nav-number">13.3.</span> <span class="nav-text">参数的内部名称和外部名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不带外部名的构造器参数"><span class="nav-number">13.4.</span> <span class="nav-text">不带外部名的构造器参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造过程中常量属性的修改"><span class="nav-number">13.5.</span> <span class="nav-text">构造过程中常量属性的修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认构造器"><span class="nav-number">13.6.</span> <span class="nav-text">默认构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体的逐一成员构造器"><span class="nav-number">13.7.</span> <span class="nav-text">结构体的逐一成员构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值类型的构造器代理"><span class="nav-number">13.8.</span> <span class="nav-text">值类型的构造器代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承和构造过程"><span class="nav-number">13.9.</span> <span class="nav-text">类的继承和构造过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定构造器和便利构造器"><span class="nav-number">13.10.</span> <span class="nav-text">指定构造器和便利构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的构造器代理规则"><span class="nav-number">13.11.</span> <span class="nav-text">类的构造器代理规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两段式构造过程"><span class="nav-number">13.12.</span> <span class="nav-text">两段式构造过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器的继承和重写"><span class="nav-number">13.13.</span> <span class="nav-text">构造器的继承和重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器的自动继承"><span class="nav-number">13.14.</span> <span class="nav-text">构造器的自动继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可失败构造器"><span class="nav-number">13.15.</span> <span class="nav-text">可失败构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类型的可失败构造器"><span class="nav-number">13.16.</span> <span class="nav-text">枚举类型的可失败构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带原始值的枚举类型的可失败构造器"><span class="nav-number">13.17.</span> <span class="nav-text">带原始值的枚举类型的可失败构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造失败的传递"><span class="nav-number">13.18.</span> <span class="nav-text">构造失败的传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写一个可失败构造器"><span class="nav-number">13.19.</span> <span class="nav-text">重写一个可失败构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init"><span class="nav-number">13.20.</span> <span class="nav-text">init!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#必要构造器"><span class="nav-number">13.21.</span> <span class="nav-text">必要构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过闭包或函数设置属性的默认值"><span class="nav-number">13.22.</span> <span class="nav-text">通过闭包或函数设置属性的默认值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#析构过程"><span class="nav-number">14.</span> <span class="nav-text">析构过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#析构语法"><span class="nav-number">14.1.</span> <span class="nav-text">析构语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动引用计数"><span class="nav-number">15.</span> <span class="nav-text">自动引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#weak"><span class="nav-number">15.1.</span> <span class="nav-text">weak</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无主引用"><span class="nav-number">15.2.</span> <span class="nav-text">无主引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无主引用以及隐式解析可选属性"><span class="nav-number">15.3.</span> <span class="nav-text">无主引用以及隐式解析可选属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包引起的循环强引用"><span class="nav-number">15.4.</span> <span class="nav-text">闭包引起的循环强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决闭包引起的循环强引用"><span class="nav-number">15.5.</span> <span class="nav-text">解决闭包引起的循环强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义捕获列表"><span class="nav-number">15.6.</span> <span class="nav-text">定义捕获列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选链式调用"><span class="nav-number">16.</span> <span class="nav-text">可选链式调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用可选链式调用代替强制展开"><span class="nav-number">16.1.</span> <span class="nav-text">使用可选链式调用代替强制展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过可选链式调用访问下标"><span class="nav-number">16.2.</span> <span class="nav-text">通过可选链式调用访问下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问可选类型的下标"><span class="nav-number">16.3.</span> <span class="nav-text">访问可选类型的下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接多层可选链式调用"><span class="nav-number">16.4.</span> <span class="nav-text">连接多层可选链式调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在方法的可选返回值上进行可选链式调用"><span class="nav-number">16.5.</span> <span class="nav-text">在方法的可选返回值上进行可选链式调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理-1"><span class="nav-number">17.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw"><span class="nav-number">17.1.</span> <span class="nav-text">throw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理错误"><span class="nav-number">17.2.</span> <span class="nav-text">处理错误</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zgjx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
